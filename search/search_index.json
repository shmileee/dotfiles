{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dotfiles","text":"<p>Welcome! This is the documentation for my dotfiles repository.</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>The preferred method of installation is to do a fresh install of macOS or Debian based Linux, then run the automated setup script:</p> <pre><code>curl -fsSL oponomarov.com/d | sh -s -- --all\n</code></pre> <p>Info</p> <p>You can see the repository in action by running <code>docker run -it shmileee/dotfiles</code> and spawning a prebuilt docker container with interactive tty. The size is almost 4GB.</p> <p>To learn about the rationale behind my setup, how to use it, what features are available and how to tweak the configurations to suit your tastes, please read the Usage Guide section.</p>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>Sane macOS defaults</li> <li>Fast and colored prompt</li> <li>Well-organized and easy to customize</li> <li>Minimal efforts to install everything</li> <li>Mostly based around Ansible, Homebrew and Chezmoi</li> <li>Single responsibility principle - one tool manages one thing</li> <li>The installation and setup is   tested weekly on:<ul> <li>real Ubuntu + macOS machines</li> <li>Ubuntu 20.04 Docker container</li> </ul> </li> <li>Supports both Apple Silicon (M1) and Intel chips</li> </ul>"},{"location":"features/1-UsageGuide/","title":"Usage Guide","text":"<p>In this section you will find write-ups on most used tools, programs, and custom scripts. Refer to each individual page for more details. </p>"},{"location":"features/1-UsageGuide/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Rationale</li> <li>Tools</li> <li>Installation</li> <li>Hotkeys</li> <li>Troubleshooting</li> </ul>"},{"location":"features/Hotkeys/","title":"Hotkeys","text":"<p>All \"system-wide\" keyboard shortcuts for macOS are bound using builtin functionality. The shortcuts are set in <code>config.yaml</code> as a <code>darwin_hotkeys</code> map that has the following structure:</p> <ul> <li><code>&lt;system keycode&gt;</code>:<ul> <li>parameters: <code>&lt;keyboard keys in ascii&gt;</code></li> <li>enabled: <code>&lt;boolean that indicates whether shortcut is enabled&gt;</code></li> </ul> </li> </ul> <p>Where <code>&lt;system keycode&gt;</code> is the <code>int</code> UID for the feature in System Preferences - Keyboard - Shortcuts, e.g.: \"Show Spotlight search\" corresponds to <code>64</code>.</p>"},{"location":"features/Hotkeys/#key-bindings","title":"Key Bindings","text":"<p>The following keybindings are available: </p> Key Combination Action Cmd+G Show Spotlight search. Cmd+Space Select the next source in input menu. <p>Note</p> <p><code>community.general.osx_defaults</code> Ansible collection does not support modifying system shortcuts yet. This is why I use <code>ansible.builtin.command</code> to accomplish the desired result, which is not idempotent.</p>"},{"location":"features/Hotkeys/#read-more","title":"Read More","text":"<ul> <li>What do the parameter values in <code>AppleSymbolicHotKeys</code> plist dict   represent?</li> </ul>"},{"location":"features/Installation/","title":"Installation","text":""},{"location":"features/Installation/#requirements","title":"Requirements","text":"<p>Operating System</p> <p>This Ansible playbook currently supports macOS and Debian-based Linux distributions. This limitation is intentional, ensuring a consistent development environment across all machines.</p>"},{"location":"features/Installation/#macos","title":"macOS","text":"<p>On a fresh installation of macOS, run the following commands:</p> <pre><code>sudo softwareupdate -i -a\nxcode-select --install\n</code></pre> <p>Installing the Xcode Command Line Tools provides <code>git</code> and <code>make</code>, which are not included by default on macOS.</p> <p>Warning</p> <p>If Homebrew is already installed on your machine, ensure that you have full ownership of all directories managed by <code>brew</code>. See this GitHub issue for more details.</p>"},{"location":"features/Installation/#running-setupsh","title":"Running <code>setup.sh</code>","text":"<p>Begin the installation process by running the <code>setup.sh</code> script. This script resolves the \"chicken or the egg\" problem by installing the essential dependencies needed to run the Ansible playbook.</p> <p>For a quick, one-step installation, you can run the script directly from a remote source (recommended only if you\u2019re comfortable with this approach):</p> <pre><code>curl -fsSL oponomarov.com/d | sh -s -- --all\n</code></pre> <p>Alternatively, you can download and review the script before executing it:</p> <pre><code>curl -fsSL https://raw.githubusercontent.com/shmileee/dotfiles/master/scripts/setup.sh &gt; setup.sh\nchmod +x setup.sh\n./setup.sh --all\n</code></pre> <p>This script will:</p> <ul> <li>Download <code>github.com/shmileee/dotfiles</code> into <code>/tmp/.dotfiles</code> using any   available tool (<code>git</code>, <code>curl</code>, or <code>wget</code>).</li> <li>If running on Linux, install the   <code>essentials</code>   system dependencies.</li> <li>Install Ansible. On Linux, this happens as part of the previous step, and on   macOS, it is handled via Homebrew.</li> <li>Attempt to install Homebrew if it is not already present.</li> <li>Execute <code>ansible.sh</code>,   which will:</li> <li>Install the <code>community.general</code> Ansible collection.</li> <li>Check for passwordless <code>sudo</code> availability. If not available, it will prompt for your password.</li> <li>Run the     <code>main.yaml</code>     Ansible playbook.</li> </ul>"},{"location":"features/Installation/#ansible","title":"Ansible","text":"<p>The main configuration is handled by the primary playbook, which sets up the system and dotfiles.</p> <p>You can customize the configuration in <code>config.yaml</code>, where you\u2019ll typically specify packages, versions (for tools managed by <code>mise</code>), and other preferences.</p> <p>The <code>dotfiles:</code> dictionary defines which repository and branch <code>chezmoi</code> will use to install your dotfiles. If you\u2019re reusing this playbook with your own dotfiles, make sure to update these variables accordingly.</p> <p>Warning</p> <p>Some Ansible tasks assume certain dotfiles are present. For example, the <code>install tmux plugins</code> task will fail if <code>tmux.conf</code> is missing or does not include <code>run '~/.tmux/plugins/tpm/tpm'</code>.</p> <p>Supported Ansible Roles:</p> <ul> <li><code>common</code>: Installs basic system dependencies on Debian-based distributions   using <code>apt</code>, or Homebrew packages and casks on macOS.</li> <li><code>fonts</code>: Installs fonts using Homebrew. (Implementation may change in the   future.)</li> <li><code>dotfiles</code>: Installs <code>chezmoi</code> via Homebrew, initializes the dotfiles   repository, and updates files.</li> <li><code>fish</code>: Installs <code>fish</code> shell using Homebrew, sets it as the default shell,   and configures <code>fisher</code> and its plugins.</li> <li><code>neovim</code>: Installs <code>neovim</code>. If <code>neovim.build_from_source</code> is <code>true</code>, then it is   compiled from source. Otherwise, a nightly Debian package is downloaded, or on   macOS, it is installed via a HEAD build from Homebrew.</li> <li><code>mise</code>: Installs the <code>mise</code> version manager for granular control over specific   tools. All managed tools and their versions are defined in <code>config.yaml</code>.</li> <li><code>docker</code>: Installs Docker using Homebrew.</li> <li><code>tmux</code>: Installs Tmux, TPM, and the plugins specified in <code>tmux.conf</code>.</li> <li><code>system_defaults</code>: Applies opinionated macOS system settings and custom   tweaks for applications like Rectangle or Alt-Tab. Use with caution, as these   settings can be disruptive and may evolve over time.</li> </ul>"},{"location":"features/Rationale/","title":"Rationale","text":"<p>Rationale</p>"},{"location":"features/Rationale/#goal","title":"Goal","text":"<p>The goal is to provide a fully automated development environment that\u2019s both easy to set up and maintain.</p>"},{"location":"features/Rationale/#why-ansible","title":"Why <code>ansible</code>?","text":"<p>In my experience, <code>ansible</code> is one of the easiest automation tools to learn. Although it has its share of nuances, its YAML-based configuration is generally straightforward to understand\u2014even for users with limited knowledge of <code>ansible</code>. It\u2019s almost like reading plain English most of the time.</p> <p>Additionally, <code>ansible</code> is like a Swiss Army knife of orchestration tools. It can be adapted to a wide range of tasks, some of which might not be supported by other popular solutions like <code>NixOS Home Manager</code>. One of its greatest strengths is that tasks, when properly described, adhere to the principle of idempotency. This means you can rerun a playbook repeatedly without worrying about unintended removal or duplication of your files.</p> <p>In a world full of automation solutions, I simply happen to enjoy using <code>ansible</code> the most.</p>"},{"location":"features/Rationale/#why-chezmoi","title":"Why <code>chezmoi</code>?","text":"<p><code>chezmoi</code> is a powerful tool for managing dotfiles. It\u2019s currently one of the most popular solutions, boasting over 6k stars on GitHub. Before <code>chezmoi</code>, I used <code>gnu stow</code>, which worked fine but lacked several features that <code>chezmoi</code> conveniently provides.</p> <p>Key benefits of <code>chezmoi</code> include:</p> <ul> <li>Flexible: Dotfiles can be templates using text/template syntax. While   <code>ansible</code> has Jinja templates, <code>chezmoi</code> offers built-in variables for platform   detection, architecture, hostname, environment variables, and more. Testing   these templates in <code>chezmoi</code> is much simpler\u2014just run <code>chezmoi execute-template &lt; file.tmpl</code>.</li> <li>Portable: <code>chezmoi</code> configurations rely solely on visible, regular files   and directories, ensuring portability across different version control systems   and operating systems.</li> <li>Transparent: Verbose and dry-run modes let you preview changes before   they\u2019re applied, giving you complete control over what happens in your home   directory.</li> <li>Practical: <code>chezmoi</code> manages hidden files, directories, private files,   and executables\u2014essentially all the typical elements of a dotfiles repository.</li> <li>Fast and Easy to Use: <code>chezmoi</code> runs in fractions of a second, and it   provides commands that simplify most common operations.</li> </ul> <p>By using <code>chezmoi</code>, I can adhere to the single-responsibility principle: managing dotfiles independently from other system configuration tasks.</p>"},{"location":"features/Rationale/#why-lazyvim","title":"Why <code>LazyVim</code>?","text":"<p>I used <code>vim</code> for years until my configuration ballooned to over 500 lines, making it a challenge to maintain. My switch to <code>neovim</code> was inspired by talks from ThePrimagen and TJ DeVries, which also made me realize I didn\u2019t fully grasp the Lua-based configuration system that <code>neovim</code> uses.</p> <p>It turned out that most of the common keymaps, plugins, and sensible defaults I was after were already configured by many in the <code>neovim</code> community. Enter <code>LazyVim</code>: it provides a community-driven framework for <code>neovim</code>, bundling common plugins and sensible defaults. This allowed me to avoid starting from scratch and reinventing the wheel. I only needed to add a few extra plugins, tweak some keybindings, and configure fewer than ten settings to feel completely at home.</p>"},{"location":"features/Rationale/#why-fish","title":"Why <code>fish</code>?","text":"<p>The <code>fish</code> ecosystem excels as an interactive shell. While I still write my scripts in <code>bash</code> for portability, the out-of-the-box features in <code>fish</code>, such as autosuggestions and robust tab completions, are too convenient to pass up.</p>"},{"location":"features/Tools/","title":"Tools","text":"<p>Tools</p> <p>Below is a non-exhaustive list of the tools and configurations used:</p> <ul> <li> <p>Dotfiles Management</p> </li> <li> <p>Chezmoi for managing dotfiles.</p> </li> <li> <p>Editor</p> </li> <li> <p>Neovim as my primary command-line editor.</p> <ul> <li>LazyVim as the main Neovim distribution.</li> </ul> </li> <li> <p>Shell</p> </li> <li> <p>Fish as my primary shell (<code>~/.config/fish</code>).</p> <ul> <li>Fisher for plugin management   (<code>fish_plugins</code>).</li> </ul> </li> <li> <p>Tmux as a terminal multiplexer (<code>tmux.conf</code>).</p> <ul> <li>Tmux Plugin Manager for managing Tmux plugins.</li> </ul> </li> <li> <p>Package Management</p> </li> <li> <p>Homebrew as my primary package manager (casks + formulas).</p> </li> <li> <p>Mise as a version manager for various system tools.</p> </li> <li> <p>Applications</p> </li> <li>Alacritty as my terminal emulator     (<code>alacritty.toml</code>).</li> <li>Brave as my primary web browser.</li> <li>Rectangle for window management.</li> <li>Fzf as a command-line fuzzy finder.</li> </ul>"}]}
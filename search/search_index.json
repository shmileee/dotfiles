{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>Install everything with single <code>curl</code> command:</p> <pre><code>curl -fsSL oponomarov.com/d | sh -s -- --all\n</code></pre> Explanation <p>The <code>oponomarov.com/d</code> is a short redirect URL that points to the <code>shmileee/dotfiles@master:scripts/setup.sh</code>. The script handles the installation of Ansible prerequisites and executes the main Ansible playbook. Both the script and playbook are designed to work with macOS and Debian-based Linux distributions.</p> <p>For a fresh macOS installation, run the following commands first:</p> <pre><code>sudo softwareupdate -i -a\nxcode-select --install\n</code></pre> <p>To initiate the setup process, run the script. Alternatively, you can download and review the script before running it:</p> <pre><code>curl -fsSL https://raw.githubusercontent.com/shmileee/dotfiles/master/scripts/setup.sh &gt; setup.sh\nchmod +x setup.sh\n./setup.sh --all\n</code></pre> <p>This script performs the following tasks:</p> <ul> <li>Downloads the repository <code>github.com/shmileee/dotfiles</code> into   <code>/tmp/.dotfiles</code> using <code>git</code>, <code>curl</code>, or <code>wget</code>.</li> <li>Installs the required system dependencies:<ul> <li>On Linux, it installs the   <code>essentials</code>.</li> <li>On macOS, dependencies are installed via Homebrew.</li> </ul> </li> <li>Installs Ansible. For Linux, this happens during the system dependencies step; for macOS, it is managed through Homebrew.</li> <li>Installs Homebrew if it is not already available (macOS only).</li> <li>Executes the <code>ansible.sh</code> script, which:<ul> <li>Installs the <code>community.general</code> Ansible collection.</li> <li>Checks for passwordless <code>sudo</code> access or prompts for a password if needed.</li> <li>Runs the <code>main.yaml</code> Ansible playbook.</li> </ul> </li> </ul>"},{"location":"#installation-flow","title":"Installation Flow","text":"<pre><code>flowchart TD\n    A[\"curl -fsSL oponomarov.com/d | sh -s -- --all\"]\n    A --&gt; B[\"git clone shmileee/dotfiles.git /tmp\"]\n\n    B --&gt; C[\"./install_dependencies.sh (apt install &lt; essentials &gt;)\"]\n    B --&gt; D[\"./install_brew.sh\"]\n\n    B --&gt; E[\"./ansible.sh\"]\n    E --&gt; F[\"install community.general, prompt if needed\"]\n    E --&gt; G[\"ansible-playbook ... main.yaml\"]\n</code></pre>"},{"location":"#running-inside-docker","title":"Running Inside Docker","text":"<p>Run <code>docker run -it shmileee/dotfiles</code> to start a Docker container that is automatically built and pushed using GitHub Actions. Alternatively, you can build it yourself:</p> <pre><code>docker buildx build --platform linux/amd64 -t dotfiles --progress plain .\n</code></pre>"},{"location":"#credits","title":"Credits","text":"<p>Many thanks to the dotfiles community.</p>"},{"location":"hotkeys/","title":"Hotkeys","text":"<p>All system-wide keyboard shortcuts for macOS are configured using built-in functionality. These shortcuts are defined in <code>config.yaml</code> under the <code>darwin_hotkeys{}</code> map, which follows this structure:</p> <ul> <li><code>&lt;system keycode&gt;</code>:<ul> <li><code>parameters</code>: <code>&lt;keyboard keys in ASCII&gt;</code></li> <li><code>enabled</code>: <code>&lt;true | false&gt;</code></li> </ul> </li> </ul> <p>Here, <code>&lt;system keycode&gt;</code> refers to the <code>int</code> UID associated with a feature in System Preferences \u2192 Keyboard \u2192 Shortcuts. For example, the keycode <code>64</code> corresponds to the \"Show Spotlight search\" shortcut.</p>"},{"location":"hotkeys/#key-bindings","title":"Key Bindings","text":"<p>The following key bindings are currently in-use:</p> Key Combination Action Cmd+G Show Spotlight search Cmd+Space Select the next source in the input menu <p>Note</p> <p>The <code>community.general.osx_defaults</code> Ansible collection does not yet support modifying system shortcuts. Therefore, <code>ansible.builtin.command</code> is used instead, which achieves the desired result but lacks idempotency.</p>"},{"location":"what-how-and-why/","title":"What, How & Why?","text":""},{"location":"what-how-and-why/#what","title":"What?","text":"<p>This repository includes:</p> <ol> <li>The <code>setup.sh</code> script: A single entry point for setting up and    configuring a new macOS or Debian-based Linux system.</li> <li>Personalized <code>ansible</code> roles and playbooks: Designed to install and    configure various development tools efficiently. These roles emphasize    idempotency and are compatible with both macOS and Debian-based distributions,    using Homebrew as the primary package manager.</li> <li>Tools and dependency management: The <code>setup.sh</code> script ensures that all    necessary tools and prerequisites are installed to enable seamless execution    of the <code>ansible-playbook</code> command.</li> <li>Personalized dotfiles: Managed with the <code>chezmoi</code> dotfiles manager,    providing a consistent and customized environment across systems.</li> </ol>"},{"location":"what-how-and-why/#how","title":"How?","text":"<p>Below is a non-exhaustive list of the tools used to achieve the desired setup:</p> <ul> <li>Dotfiles management: <code>chezmoi</code>.</li> <li>Editor<ul> <li><code>neovim</code> as my primary command-line editor.</li> <li><code>lazyvim</code> as the main <code>neovim</code> distribution.</li> </ul> </li> <li>Shell<ul> <li><code>fish</code> as my primary shell (<code>~/.config/fish</code>).</li> <li><code>fisher</code> for plugin management   (<code>fish_plugins</code>).</li> </ul> </li> <li>Terminal:<ul> <li><code>alacritty</code> as my terminal emulator   (<code>alacritty.toml</code>).</li> <li><code>tmux</code> as a terminal multiplexer (<code>tmux.conf</code>).<ul> <li><code>tpm</code> for managing <code>tmux</code> plugins.</li> </ul> </li> </ul> </li> <li>Package management:<ul> <li><code>homebrew</code> as my primary package manager (casks + formulas).</li> <li><code>mise</code> as a version manager for various system tools.</li> </ul> </li> </ul> <p>All of these tools are installed with <code>ansible</code>. The main configuration is handled by the primary playbook, which sets up the system and dotfiles. You can customize the configuration in <code>config.yaml</code>, where you\u2019ll typically specify packages, versions (for tools managed by <code>mise</code>), and other preferences. The <code>dotfiles{}</code> dictionary defines which repository and branch <code>chezmoi</code> will use to install your dotfiles from.</p> <p>Warning</p> <p>If you\u2019re reusing this playbook with your own dotfiles, make sure to update these variables accordingly.</p> Supported <code>ansible</code> roles <ul> <li><code>common</code>: Installs basic system dependencies on Debian-based distributions   using <code>apt</code>, or <code>brew</code> packages and casks on macOS.</li> <li><code>fonts</code>: Installs fonts using <code>brew</code>.</li> <li><code>dotfiles</code>: Installs <code>chezmoi</code> via <code>brew</code>, initializes the dotfiles   repository, and updates files.</li> <li><code>fish</code>: Installs <code>fish</code> shell using <code>brew</code>, sets it as the default shell,   and configures <code>fisher</code> and its plugins.</li> <li><code>neovim</code>: Installs <code>neovim</code>. If <code>neovim.build_from_source</code> is <code>true</code>, then it is   compiled from source. Otherwise, a nightly Debian package is downloaded, or on   macOS, it is installed via a <code>brew</code>.</li> <li><code>mise</code>: Installs the <code>mise</code> version manager for granular control over specific   tools. All managed tools and their versions are defined in <code>config.yaml</code>.</li> <li><code>docker</code>: Installs Docker using <code>brew</code>.</li> <li><code>tmux</code>: Installs <code>tmux</code>, <code>tpm</code>, and the plugins specified in <code>tmux.conf</code>.</li> <li><code>system_defaults</code>: Applies opinionated macOS system settings and custom   tweaks for applications like Rectangle or Alt-Tab. Use with caution, as these   settings can be disruptive and may evolve over time.</li> </ul>"},{"location":"what-how-and-why/#why","title":"Why?","text":"<p>My goal was to provide a fully automated development environment that\u2019s both easy to set up and maintain.</p>"},{"location":"what-how-and-why/#why-ansible","title":"Why <code>ansible</code>?","text":"<p>In my experience, <code>ansible</code> is one of the easiest automation tools to learn. Although it has its share of nuances, its YAML-based configuration is generally straightforward to understand, even for users with limited knowledge of <code>ansible</code>. It\u2019s almost like reading plain English most of the time.</p> <p>Additionally, <code>ansible</code> is like a Swiss Army knife of orchestration tools. It can be adapted to a wide range of tasks, some of which might not be supported by other popular solutions like <code>NixOS Home Manager</code>. One of its greatest strengths is that tasks, when properly described, adhere to the principle of idempotency. This means you can rerun a playbook repeatedly without worrying about unintended removal or duplication of your files.</p> <p>In a world full of automation solutions, I simply happen to enjoy using <code>ansible</code> the most.</p>"},{"location":"what-how-and-why/#why-chezmoi","title":"Why <code>chezmoi</code>?","text":"<p><code>chezmoi</code> is a powerful tool for managing dotfiles. It\u2019s currently one of the most popular solutions. Before <code>chezmoi</code>, I used <code>gnu stow</code>, which worked fine but lacked several features that <code>chezmoi</code> conveniently provides.</p> <p>Key benefits of <code>chezmoi</code> include:</p> <ul> <li>Flexible: Dotfiles can be templates using <code>text/template</code> syntax. While   <code>ansible</code> has Jinja templates, <code>chezmoi</code> offers built-in variables for platform   detection, architecture, hostname, environment variables, and more. Testing   these templates in <code>chezmoi</code> is much simpler \u2014 just run <code>chezmoi execute-template &lt; file.tmpl</code>.</li> <li>Portable: <code>chezmoi</code> configurations rely solely on visible, regular files   and directories, ensuring portability across different version control systems   and operating systems.</li> <li>Transparent: Verbose and dry-run modes let you preview changes before   they\u2019re applied, giving you complete control over what happens in your home   directory.</li> <li>Practical: <code>chezmoi</code> manages hidden files, directories, private files,   and executables \u2014 essentially all the typical elements of a dotfiles   repository.</li> <li>Fast and easy to use: <code>chezmoi</code> runs in fractions of a second, and it   provides commands that simplify most common operations.</li> </ul> <p>By using <code>chezmoi</code>, I can adhere to the single-responsibility principle: managing dotfiles independently from other system configuration tasks.</p>"},{"location":"what-how-and-why/#why-lazyvim","title":"Why <code>lazyvim</code>?","text":"<p>I used <code>vim</code> for years until my configuration ballooned to over 500 lines, making it a challenge to maintain. My switch to <code>neovim</code> was inspired by talks from ThePrimagen and TJ DeVries, which also made me realize I didn\u2019t fully grasp the Lua-based configuration system that <code>neovim</code> uses.</p> <p>It turned out that most of the common keymaps, plugins, and sensible defaults I was after were already configured by many in the <code>neovim</code> community. This is how I discovered <code>lazyvim</code>: it provides a community-driven framework for <code>neovim</code>, bundling common plugins and sensible defaults. This allowed me to avoid starting from scratch and reinventing the wheel. I only needed to add a few extra plugins, tweak some keybindings, and configure fewer than ten settings to feel completely at home.</p>"},{"location":"what-how-and-why/#why-fish","title":"Why <code>fish</code>?","text":"<p>The <code>fish</code> ecosystem excels as an interactive shell. While I still write my scripts in <code>bash</code> for portability, the out-of-the-box features in <code>fish</code>, such as autosuggestions and robust tab completions, are too convenient to pass up.</p>"},{"location":"what-how-and-why/#why-mise","title":"Why <code>mise</code>?","text":"<p>I've described this in a blog post here.</p>"}]}